<?xml version="1.0" encoding="UTF-8" ?>
<!--                                                                      -->
<!-- Generated by Semifore, Inc. csrCompile                               -->
<!--   Version: 2009.01                                                   -->
<!--   Released on: Mar 25 2009 08:57:17                                  -->
<!--   Spirit IP-XACT 1.4 output                                          -->
<!--                                                                      -->
<!-- Input files:                                                         -->
<!--    pci.rdl                                                           -->
<!--                                                                      -->
<!-- Included files:                                                      -->
<!--    ./pci_bar.rdl                                                     -->
<!--    ./pci_enums.rdl                                                   -->
<!--                                                                      -->
<!-- Generated on: Wed Mar 25 09:48:56 2009                               -->
<!--           by: weber                                                  -->
<!--                                                                      -->
<!--
// Revision:    $Revision:$
// Date:        $Date:$
//
// Copyright (c) 2009 The SPIRIT Consortium.
//
// This work forms part of a deliverable of The SPIRIT Consortium.
//
// Use of these materials are governed by the legal terms and conditions
// outlined in the disclaimer available from www.spiritconsortium.org.
//
// This source file is provided on an AS IS basis.  The SPIRIT
// Consortium disclaims any warranty express or implied including
// any warranty of merchantability and fitness for use for a
// particular purpose.
//
// The user of the source file shall indemnify and hold The SPIRIT
// Consortium and its members harmless from any damages or liability.
// Users are requested to provide feedback to The SPIRIT Consortium
// using either mailto:feedback@lists.spiritconsortium.org or the forms at
// http://www.spiritconsortium.org/about/contact_us/
//
// This file may be copied, and distributed, with or without
// modifications; this notice must be included on any copy.
-->
<spirit:memoryMaps
 xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009 ./xact/index.xsd"
 >
 <spirit:memoryMap>
  <spirit:name>pci_map</spirit:name>
  <spirit:addressBlock>
   <spirit:name>pci_map</spirit:name>
   <spirit:baseAddress>0x0</spirit:baseAddress>
   <spirit:range>0x40</spirit:range>
   <spirit:width>64</spirit:width>
   <spirit:usage>register</spirit:usage>
   <spirit:volatile>true</spirit:volatile>
   <spirit:register>
    <spirit:name>PCIE_REG_VENDOR_ID</spirit:name>
    <spirit:displayName>Vendor ID</spirit:displayName>
    <spirit:description>This field identifies the manufacturer of the device. Valid vendor identifiers are allocated by the PCI SIG to ensure uniqueness. 0 FFFFh is an invalid value for Vendor ID.</spirit:description>
    <spirit:addressOffset>0x0</spirit:addressOffset>
    <spirit:size>16</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xffff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>value</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>16</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_DEVICE_ID</spirit:name>
    <spirit:displayName>Device ID</spirit:displayName>
    <spirit:description>This field identifies the particular device. This identifier is allocated by the vendor.</spirit:description>
    <spirit:addressOffset>0x2</spirit:addressOffset>
    <spirit:size>16</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xffff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>value</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>16</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_COMMAND</spirit:name>
    <spirit:displayName>Command</spirit:displayName>
    <spirit:description>The Command register provides coarse control over a device's ability to generate and respond to PCI cycles. When a 0 is written to this register, the device is logically disconnected from the PCI bus for all accesses except configuration accesses. All devices are required to support this base level of functionality. Individual bits in the Command register may or may not be implemented depending on a device's functionality. For instance, devices that do not implement an I/O Space will not implement a writable element at bit location 0 of the Command register. Devices typically power up with all 0's in this register, but Section 6.6 explains some exceptions. Figure 6-2 shows the layout of the register and Table 6-1 explains the meanings of the different bits in the Command register.</spirit:description>
    <spirit:addressOffset>0x4</spirit:addressOffset>
    <spirit:size>16</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xffff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>IOen</spirit:name>
     <spirit:displayName>IOen</spirit:displayName>
     <spirit:description>Controls a device's response to I/O Space accesses. A value of 0 disables the device response. A value of 1 allows the device to respond to I/O Space accesses. State after RST# is 0.</spirit:description>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>MEMen</spirit:name>
     <spirit:displayName>MEMen</spirit:displayName>
     <spirit:description>Controls a device's response to Memory Space accesses. A value of 0 disables the device response. A value of 1 allows the device to respond to Memory Space accesses. State after RST# is 0.</spirit:description>
     <spirit:bitOffset>1</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>MasEn</spirit:name>
     <spirit:displayName>MasEn</spirit:displayName>
     <spirit:description>Controls a device's ability to act as a master on the PCI bus. A value of 0 disables the device from generating PCI accesses. A value of 1 allows the device to behave as a bus master. State after RST# is 0.</spirit:description>
     <spirit:bitOffset>2</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>speCylEn</spirit:name>
     <spirit:displayName>speCylEn</spirit:displayName>
     <spirit:description>Controls a device's action on Special Cycle operations. A value of 0 causes the device to ignore all Special Cycle operations. A value of 1 allows the device to monitor Special Cycle operations. State after RST# is 0.</spirit:description>
     <spirit:bitOffset>3</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>MwrInv</spirit:name>
     <spirit:displayName>MwrInv</spirit:displayName>
     <spirit:description>This is an enable bit for using the Memory Write and Invalidate command. When this bit is 1, masters may generate the command. When it is 0, Memory Write must be used instead. State after RST# is 0. This bit must be implemented by master devices that can generate the Memory Write and Invalidate command.</spirit:description>
     <spirit:bitOffset>4</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>VGA</spirit:name>
     <spirit:displayName>VGA</spirit:displayName>
     <spirit:description>This bit controls how VGA compatible and graphics devices handle accesses to VGA palette registers. When this bit is 1, palette snooping is enabled (i.e., the device does not respond to palette register writes and snoops the data). When the bit is 0, the device should treat palette write accesses like all other accesses. VGA compatible devices should implement this bit. Refer to Section 3.10. for more details on VGA palette snooping.</spirit:description>
     <spirit:bitOffset>5</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>PERRen</spirit:name>
     <spirit:displayName>PERRen</spirit:displayName>
     <spirit:description>This bit controls the device's response to parity errors. When the bit is set, the device must take its normal action when a parity error is detected. When the bit is 0, the device sets its Detected Parity Error status bit (bit 15 in the Status register) when an error is detected, but does not assert PERR# and continues normal operation. This bit's state after RST# is 0. Devices that check parity must implement this bit. Devices are still required to generate parity even if parity checking is disabled.</spirit:description>
     <spirit:bitOffset>6</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>IDSEL</spirit:name>
     <spirit:displayName>IDSEL</spirit:displayName>
     <spirit:description>Deprecated: Hardwire this bit to 0</spirit:description>
     <spirit:bitOffset>7</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>SERRen</spirit:name>
     <spirit:displayName>SERRen</spirit:displayName>
     <spirit:description>This bit is an enable bit for the SERR# driver. A value of 0 disables the SERR# driver. A value of 1 enables the SERR# driver. This bit's state after RST# is 0. All devices that have an SERR# pin must implement this bit. Address parity errors are reported only if this bit and bit 6 are 1.</spirit:description>
     <spirit:bitOffset>8</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>FastB2B</spirit:name>
     <spirit:displayName>FastB2B</spirit:displayName>
     <spirit:description>This optional read/write bit controls whether or not a master can do fast back-to-back transactions to different devices. Initialization software will set the bit if all targets are fast back-to-back capable. A value of 1 means the master is allowed to generate fast back-to-back transactions to different agents as described in Section 3.4.2. A value of 0 means fast back-to-back transactions are only allowed to the same agent. This bit's state after RST# is 0</spirit:description>
     <spirit:bitOffset>9</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>IntrDis</spirit:name>
     <spirit:displayName>IntrDis</spirit:displayName>
     <spirit:description>This bit disables the device/function from asserting INTx#. A value of 0 enables the assertion of its INTx# signal. A value of 1 disables the assertion of its INTx# signal. This bit's state after RST# is 0. Refer to Section 6.8.1.3 for control of MSI.</spirit:description>
     <spirit:bitOffset>10</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>RsvdP</spirit:name>
     <spirit:displayName>RsvdP</spirit:displayName>
     <spirit:bitOffset>11</spirit:bitOffset>
     <spirit:bitWidth>5</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_STATUS</spirit:name>
    <spirit:displayName>Status</spirit:displayName>
    <spirit:description>The Status register is used to record status information for PCI bus related events. The definition of each of the bits is given in Table 6-2 and the layout of the register is shown in Figure 6-3. Devices may not need to implement all bits, depending on device functionality. For instance, a device that acts as a target, but will never signal Target-Abort, would not implement bit 11. Reserved bits should be read-only and return zero when read. Reads to this register behave normally. Writes are slightly different in that bits can be reset, but not set. A one bit is reset (if it is not read-only) whenever the register is written, and the write data in the corresponding bit location is a 1. For instance, to clear bit 14 and not affect any other bits, write the value 0100_0000_0000_0000b to the register.</spirit:description>
    <spirit:addressOffset>0x6</spirit:addressOffset>
    <spirit:size>16</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x10</spirit:value>
     <spirit:mask>0x57</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>IntrStatus</spirit:name>
     <spirit:displayName>IntrStatus</spirit:displayName>
     <spirit:description>This read-only bit reflects the state of the interrupt in the device/function. Only when the Interrupt Disable bit in the command register is a 0 and this Interrupt Status bit is a 1, will the device's/function's INTx# signal be asserted. Setting the Interrupt Disable bit to a 1 has no effect on the state of this bit.</spirit:description>
     <spirit:bitOffset>3</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>hasCapList</spirit:name>
     <spirit:displayName>hasCapList</spirit:displayName>
     <spirit:description>This optional read-only bit indicates whether or not this device implements the pointer for a New Capabilities linked list at offset 34h. A value of zero indicates that no New Capabilities linked list is available. A value of one indicates that the value read at offset 34h is a pointer in Configuration Space to a linked list of new capabilities. Refer to Section 6.7. for details on New Capabilities.</spirit:description>
     <spirit:bitOffset>4</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>capable_66Mhz</spirit:name>
     <spirit:displayName>capable_66Mhz</spirit:displayName>
     <spirit:description>This optional read-only bit indicates whether or not this device is capable of running at 66 MHz as defined in Chapter 7. A value of zero indicates 33 MHz. A value of 1 indicates that the device is 66 MHz capable.</spirit:description>
     <spirit:bitOffset>5</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>FastB2B</spirit:name>
     <spirit:displayName>FastB2B</spirit:displayName>
     <spirit:description>This optional read-only bit indicates whether or not the target is capable of accepting fast back-to-back transactions when the transactions are not to the same agent. This bit can be set to 1 if the device can accept these transactions and must be set to 0 otherwise. Refer to Section 3.4.2. for a complete description of requirements for setting this bit.</spirit:description>
     <spirit:bitOffset>7</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>MasDParErr</spirit:name>
     <spirit:displayName>MasDParErr</spirit:displayName>
     <spirit:description>This bit is only implemented by bus masters. It is set when three conditions are met: 1) the bus agent asserted PERR# itself (on a read) or observed PERR# asserted (on a write); 2) the agent setting the bit acted as the bus master for the operation in which the error occurred; and 3) the Parity Error Response bit (Command register) is set.</spirit:description>
     <spirit:bitOffset>8</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>DEVSEL</spirit:name>
     <spirit:displayName>DEVSEL</spirit:displayName>
     <spirit:description>These bits encode the timing of DEVSEL#. Section 3.6.1 specifies three allowable timings for assertion of DEVSEL#. These are encoded as 00b for fast, 01b for medium, and 10b for slow (11b is reserved). These bits are read-only and must indicate the slowest time that a device asserts DEVSEL# for any bus command except Configuration Read and Configuration Write.</spirit:description>
     <spirit:bitOffset>9</spirit:bitOffset>
     <spirit:bitWidth>2</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
     <spirit:enumeratedValues>
     <spirit:enumeratedValue>
      <spirit:name>fast</spirit:name>
      <spirit:value>0x0</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>medium</spirit:name>
      <spirit:value>0x1</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>slow</spirit:name>
      <spirit:value>0x2</spirit:value>
     </spirit:enumeratedValue>
    </spirit:enumeratedValues>
    </spirit:field>
    <spirit:field>
     <spirit:name>SigTarAb</spirit:name>
     <spirit:displayName>SigTarAb</spirit:displayName>
     <spirit:description>This bit must be set by a target device whenever it terminates a transaction with Target-Abort. Devices that will never signal Target- Abort do not need to implement this bit.</spirit:description>
     <spirit:bitOffset>11</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>RcdTarAb</spirit:name>
     <spirit:displayName>RcdTarAb</spirit:displayName>
     <spirit:description>This bit must be set by a master device whenever its transaction is terminated with Target-Abort. All master devices must implement this bit.</spirit:description>
     <spirit:bitOffset>12</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>RcdMasAb</spirit:name>
     <spirit:displayName>RcdMasAb</spirit:displayName>
     <spirit:description>This bit must be set by a master device whenever its transaction (except for Special Cycle) is terminated with Master-Abort. All master devices must implement this bit.</spirit:description>
     <spirit:bitOffset>13</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>SigSysErr</spirit:name>
     <spirit:displayName>SigSysErr</spirit:displayName>
     <spirit:description>This bit must be set whenever the device asserts SERR#. Devices who will never assert SERR# do not need to implement this bit.</spirit:description>
     <spirit:bitOffset>14</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>DetParErr</spirit:name>
     <spirit:displayName>DetParErr</spirit:displayName>
     <spirit:description>This bit must be set by the device whenever it detects a parity error, even if parity error handling is disabled (as controlled by bit 6 in the Command register).</spirit:description>
     <spirit:bitOffset>15</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_REV_ID_CLASS_CODE</spirit:name>
    <spirit:displayName>Class Code</spirit:displayName>
    <spirit:description>This register contains two primary fields. Revision ID and Class Code. The revision ID field specifies a device specific revision identifier. The value is chosen by the vendor. Zero is an acceptable value. The Class Code field is read-only and is used to identify the generic function of the device and, in some cases, a specific registerlevel programming interface. The register is broken into three bytesize fields.</spirit:description>
    <spirit:addressOffset>0x8</spirit:addressOffset>
    <spirit:size>32</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xffffffff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>rev_id</spirit:name>
     <spirit:displayName>Revision ID</spirit:displayName>
     <spirit:description>This register specifies a device specific revision identifier. The value is chosen by the vendor. Zero is an acceptable value. This field should be viewed as a vendor defined extension to the Device ID.</spirit:description>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>Interface</spirit:name>
     <spirit:displayName>Interface</spirit:displayName>
     <spirit:description>The Class Code register is read-only and is used to identify the generic function of the device and, in some cases, a specific registerlevel programming interface. The register is broken into three bytesize fields. The upper byte (at offset 0Bh) is a base class code which broadly classifies the type of function the device performs. The middle byte (at offset 0Ah) is a sub-class code which identifies more specifically the function of the device. The lower byte (at offset 09h) identifies a specific register-level programming interface (if any) so that device independent software can interact with the device. Encodings for base class, sub-class, and programming interface are provided in Appendix D. All unspecified encodings are reserved.</spirit:description>
     <spirit:bitOffset>8</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>subClass</spirit:name>
     <spirit:displayName>subClass</spirit:displayName>
     <spirit:bitOffset>16</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>baseClass</spirit:name>
     <spirit:displayName>baseClass</spirit:displayName>
     <spirit:bitOffset>24</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
     <spirit:enumeratedValues>
     <spirit:enumeratedValue>
      <spirit:name>legacy</spirit:name>
      <spirit:value>0x0</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>storage_cntlr</spirit:name>
      <spirit:value>0x1</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>network_cntlr</spirit:name>
      <spirit:value>0x2</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>disp_cntlr</spirit:name>
      <spirit:value>0x3</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>multimedia_dev</spirit:name>
      <spirit:value>0x4</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>mem_cntlr</spirit:name>
      <spirit:value>0x5</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>pci_bridge</spirit:name>
      <spirit:value>0x6</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>simpl_comm_cntrl</spirit:name>
      <spirit:value>0x7</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>base_acc</spirit:name>
      <spirit:value>0x8</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>input_dev</spirit:name>
      <spirit:value>0x9</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>dock</spirit:name>
      <spirit:value>0xa</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>processor</spirit:name>
      <spirit:value>0xb</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>serial_cntlr</spirit:name>
      <spirit:value>0xc</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>wireless_cntlr</spirit:name>
      <spirit:value>0xd</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>smart_io_cntlr</spirit:name>
      <spirit:value>0xe</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>sat_comm_cntlr</spirit:name>
      <spirit:value>0xf</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>crypto_cntlr</spirit:name>
      <spirit:value>0x10</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>data_acq_cntlr</spirit:name>
      <spirit:value>0x11</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>other</spirit:name>
      <spirit:value>0xff</spirit:value>
     </spirit:enumeratedValue>
     </spirit:enumeratedValues>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_CACHE_L_SIZE</spirit:name>
    <spirit:displayName>Cache Line Size</spirit:displayName>
    <spirit:description>This read/write register specifies the system cacheline size in units of DWORDs. This register must be implemented by master devices that can generate the Memory Write and Invalidate command (refer to Section 3.1.1). The value in this register is also used by master devices to determine whether to use Read, Read Line, or Read Multiple commands for accessing memory (refer to Section 3.1.2). Slave devices that want to allow memory bursting using cacheline wrap addressing mode (refer to Section 3.2.2.2) must implement this register to know when a burst sequence wraps to the beginning of the cacheline. This field must be initialized to 0 at RST#. A device may limit the number of cacheline sizes that it can support. For example, it may accept only powers of 2 less than 128. If an unsupported value is written to the CacheLine Size register, the device should behave as if a value of 0 was written.</spirit:description>
    <spirit:addressOffset>0xc</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>value</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_MASTER_LAT_TIMER</spirit:name>
    <spirit:displayName>Master Latency Timer</spirit:displayName>
    <spirit:description>This register specifies, in units of PCI bus clocks, the value of the Latency Timer for this PCI bus master (refer to Section 3.5.4). This register must be implemented as writable by any master that can burst more than two data phases. This register may be implemented as read-only for devices that burst two or fewer data phases, but the hardwired value must be limited to 16 or less. A typical implementation would be to build the five high-order bits (leaving the bottom three as read-only), resulting in a timer granularity of eight clocks. At RST#, the register must be initialized to 0 (if programmable).</spirit:description>
    <spirit:addressOffset>0xd</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>value</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_HEADER_TYPE</spirit:name>
    <spirit:displayName>Header Type</spirit:displayName>
    <spirit:description>This byte identifies the layout of the second part of the predefined header (beginning at byte 10h in Configuration Space) and also whether or not the device contains multiple functions. Bit 7 in this register is used to identify a multi-function device. If the bit is 0, then the device is single function. If the bit is 1, then the device has multiple functions. Bits 6 through 0 identify the layout of the second part of the predefined header. The encoding 00h specifies the layout shown in Figure 6-1. The encoding 01h is defined for PCI-to-PCI bridges and is defined in the document PCI to PCI Bridge Architecture Specification. The encoding 02h is defined for a CardBus bridge and is documented in the PC Card Standard. All other encodings are reserved. </spirit:description>
    <spirit:addressOffset>0xe</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>hdrType</spirit:name>
     <spirit:displayName>hdrType</spirit:displayName>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>7</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
     <spirit:enumeratedValues>
     <spirit:enumeratedValue>
      <spirit:name>normal</spirit:name>
      <spirit:value>0x0</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>pci_bridge</spirit:name>
      <spirit:value>0x1</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>cardbus_bridge</spirit:name>
      <spirit:value>0x10</spirit:value>
     </spirit:enumeratedValue>
     </spirit:enumeratedValues>
    </spirit:field>
    <spirit:field>
     <spirit:name>isMulFunc</spirit:name>
     <spirit:displayName>isMulFunc</spirit:displayName>
     <spirit:bitOffset>7</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_BIST</spirit:name>
    <spirit:displayName>BIST</spirit:displayName>
    <spirit:description>This optional register is used for control and status of BIST. Devices that do not support BIST must always return a value of 0 (i.e., treat it as a reserved register). A device whose BIST is invoked must not prevent normal operation of the PCI bus. Figure 6-4 shows the register layout and Table 6-3 describes the bits in the register.</spirit:description>
    <spirit:addressOffset>0xf</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xb0</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>cplCode</spirit:name>
     <spirit:displayName>cplCode</spirit:displayName>
     <spirit:description>A value of 0 means the device has passed its test. Non-zero values mean the device failed. Device-specific failure codes can be encoded in the non-zero value.</spirit:description>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>4</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>start</spirit:name>
     <spirit:displayName>start</spirit:displayName>
     <spirit:description>Write a 1 to invoke BIST. Device resets the bit when BIST is complete. Software should fail the device if BIST is not complete after 2 seconds.</spirit:description>
     <spirit:bitOffset>6</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>capable</spirit:name>
     <spirit:displayName>capable</spirit:displayName>
     <spirit:description>Return 1 if device supports BIST. Return 0 if the device is not BIST capable.</spirit:description>
     <spirit:bitOffset>7</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>bar0</spirit:name>
    <spirit:displayName>PCI Memory Space: Base Address Register</spirit:displayName>
    <spirit:description>support mapping into a 64-bit address space) with bit 0 hardwired to a 0. For Memory Base Address registers, bits 2 and 1 have an encoded meaning as shown in Table 6-4. Bit 3 should be set to 1 if the data is prefetchable and reset to 0 otherwise. A device can mark a range as prefetchable if there are no side effects on reads, the device returns all bytes on reads regardless of the byte enables, and host bridges can merge processor writes (refer to Section 3.2.3) into this range45 without causing errors. Bits 0-3 are read-only.</spirit:description>
    <spirit:addressOffset>0x10</spirit:addressOffset>
    <spirit:size>32</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0x7</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>isIO</spirit:name>
     <spirit:displayName>isIO</spirit:displayName>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>memType</spirit:name>
     <spirit:displayName>memType</spirit:displayName>
     <spirit:bitOffset>1</spirit:bitOffset>
     <spirit:bitWidth>2</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
     <spirit:enumeratedValues>
     <spirit:enumeratedValue>
      <spirit:name>mem_32</spirit:name>
      <spirit:value>0x0</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>mem_64</spirit:name>
      <spirit:value>0x2</spirit:value>
     </spirit:enumeratedValue>
     </spirit:enumeratedValues>
    </spirit:field>
    <spirit:field>
     <spirit:name>prefetchable</spirit:name>
     <spirit:displayName>prefetchable</spirit:displayName>
     <spirit:description>Set to one. If there are no side effects on reads, the device returns all bytes on reads regardless of the byte enables, and host bridges can merge processor writes into this range without causing errors. Bit must be set to zero otherwise.</spirit:description>
     <spirit:bitOffset>3</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>address</spirit:name>
     <spirit:displayName>Address</spirit:displayName>
     <spirit:bitOffset>4</spirit:bitOffset>
     <spirit:bitWidth>28</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>bar1</spirit:name>
    <spirit:displayName>PCI Memory Space: Base Address Register</spirit:displayName>
    <spirit:description>support mapping into a 64-bit address space) with bit 0 hardwired to a 0. For Memory Base Address registers, bits 2 and 1 have an encoded meaning as shown in Table 6-4. Bit 3 should be set to 1 if the data is prefetchable and reset to 0 otherwise. A device can mark a range as prefetchable if there are no side effects on reads, the device returns all bytes on reads regardless of the byte enables, and host bridges can merge processor writes (refer to Section 3.2.3) into this range45 without causing errors. Bits 0-3 are read-only.</spirit:description>
    <spirit:addressOffset>0x18</spirit:addressOffset>
    <spirit:size>64</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x4</spirit:value>
     <spirit:mask>0xffffffffffffffff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>isIO</spirit:name>
     <spirit:displayName>isIO</spirit:displayName>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>memType</spirit:name>
     <spirit:displayName>memType</spirit:displayName>
     <spirit:bitOffset>1</spirit:bitOffset>
     <spirit:bitWidth>2</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
     <spirit:enumeratedValues>
     <spirit:enumeratedValue>
      <spirit:name>mem_32</spirit:name>
      <spirit:value>0x0</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>mem_64</spirit:name>
      <spirit:value>0x2</spirit:value>
     </spirit:enumeratedValue>
     </spirit:enumeratedValues>
    </spirit:field>
    <spirit:field>
     <spirit:name>prefetchable</spirit:name>
     <spirit:displayName>prefetchable</spirit:displayName>
     <spirit:description>Set to one. If there are no side effects on reads, the device returns all bytes on reads regardless of the byte enables, and host bridges can merge processor writes into this range without causing errors. Bit must be set to zero otherwise.</spirit:description>
     <spirit:bitOffset>3</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>address</spirit:name>
     <spirit:displayName>Address</spirit:displayName>
     <spirit:bitOffset>4</spirit:bitOffset>
     <spirit:bitWidth>60</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>bar3</spirit:name>
    <spirit:displayName>PCI I/O Space: Base Address Register</spirit:displayName>
    <spirit:description>Base Address registers that map into I/O Space are always 32 bits wide with bit 0 hardwired to a 1. Bit 1 is reserved and must return 0 on reads and the other bits are used to map the device into I/O Space.</spirit:description>
    <spirit:addressOffset>0x20</spirit:addressOffset>
    <spirit:size>32</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x1</spirit:value>
     <spirit:mask>0x3</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>isIO</spirit:name>
     <spirit:displayName>isIO</spirit:displayName>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>address</spirit:name>
     <spirit:displayName>Address</spirit:displayName>
     <spirit:bitOffset>2</spirit:bitOffset>
     <spirit:bitWidth>30</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_CARDBUS</spirit:name>
    <spirit:displayName>Cardbus CIS Pointer</spirit:displayName>
    <spirit:description>This optional register is used by those devices that want to share silicon between CardBus and PCI. The field is used to point to the Card Information Structure (CIS) for the CardBus card. For a detailed explanation of the CIS, refer to the PCMCIA v2.10 specification. The subject is covered under the heading Card Metaformat and describes the types of information provided and the organization of this information.</spirit:description>
    <spirit:addressOffset>0x28</spirit:addressOffset>
    <spirit:size>32</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xffffffff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>value</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>32</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_SUBSYS_VENDOR_ID</spirit:name>
    <spirit:displayName>Subsystem ID and Vendor ID</spirit:displayName>
    <spirit:description>These registers are used to uniquely identify the add-in card or subsystem where the PCI device resides. They provide a mechanism for add-in card vendors to distinguish their add- in cards from one another even though the add-in cards may have the same PCI controller on them (and, therefore, the same Vendor ID and Device ID). Implementation of these registers is required for all PCI devices except those that have a base class 6 with sub class 0-4 (0, 1, 2, 3, 4), or a base class 8 with sub class 0-3 (0, 1, 2, 3). Subsystem Vendor IDs can be obtained from the PCI SIG and are used to identify the vendor of the add-in card or subsystem. Values for the Subsystem ID are vendor specific. Values in these registers must be loaded and valid prior to the system firmware or any system software accessing the PCI Configuration Space. How these values are loaded is not specified but could be done during the manufacturing process or loaded from external logic (e.g., strapping options, serial ROMs, etc.). These values must not be loaded using expansion ROM software because expansion ROM software is not guaranteed to be run during POST in all systems. Devices are responsible for guaranteeing the data is valid before allowing reads to these registers to complete. This can be done by responding to any accesses with Retry until the data is valid. If a device is designed to be used exclusively on the system board, the system vendor may use system specific software to initialize these registers after each power-on.</spirit:description>
    <spirit:addressOffset>0x2c</spirit:addressOffset>
    <spirit:size>32</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0xffffffff</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>subsys_id</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>16</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>vendor_id</spirit:name>
     <spirit:bitOffset>16</spirit:bitOffset>
     <spirit:bitWidth>16</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_EROM_BASE</spirit:name>
    <spirit:displayName>Expansion ROM Base Address</spirit:displayName>
    <spirit:description>Some PCI devices, especially those that are intended for use on add-in cards in PC architectures, require local EPROMs for expansion ROM (refer to the PCI Firmware Specification, Revision 3.0 Section 6.3 for a definition of ROM contents). The four-byte register at offset 30h in a type 00h predefined header is defined to handle the base address and size information for this expansion ROM. Figure 6-7 shows how this word is organized. The register functions exactly like a 32-bit Base Address register except that the encoding (and usage) of the bottom bits is different. The upper 21 bits correspond to the upper 21 bits of the Expansion ROM base address. The number of bits (out of these 21) that a device actually implements depends on how much address space the device requires. For instance, a device that requires a 64 KB area to map its expansion ROM would implement the top 16 bits in the register, leaving the bottom 5 (out of these 21) hardwired to 0. Devices that support an expansion ROM must implement this register. Device independent configuration software can determine how much address space the device requires by writing a value of all 1's to the address portion of the register and then reading the value back. The device will return 0's in all don't-care bits, effectively specifying the size and alignment requirements. The amount of address space a device requests must not be greater than 16 MB. Bit 0 in the register is used to control whether or not the device accepts accesses to its expansion ROM. When this bit is 0, the device's expansion ROM address space is disabled. When the bit is 1, address decoding is enabled using the parameters in the other part of the base register. This allows a device to be used with or without an expansion ROM depending on system configuration. The Memory Space bit in the Command register has precedence over the Expansion ROM enable bit. A device must respond to accesses to its expansion ROM only if both the Memory Space bit and the Expansion ROM Base Address Enable bit are set to 1. This bit's state after RST# is 0. In order to minimize the number of address decoders needed, a device may share a decoder between the Expansion ROM Base Address register and other Base Address registers.47 When expansion ROM decode is enabled, the decoder is used for accesses to the expansion ROM and device independent software must not access the device through any other Base Address registers.</spirit:description>
    <spirit:addressOffset>0x30</spirit:addressOffset>
    <spirit:size>32</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:reset>
     <spirit:value>0x0</spirit:value>
     <spirit:mask>0x7fe</spirit:mask>
    </spirit:reset>
    <spirit:field>
     <spirit:name>Enable</spirit:name>
     <spirit:displayName>Enable</spirit:displayName>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>1</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>RsvdP</spirit:name>
     <spirit:displayName>RsvdP</spirit:displayName>
     <spirit:bitOffset>1</spirit:bitOffset>
     <spirit:bitWidth>10</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
    <spirit:field>
     <spirit:name>addr</spirit:name>
     <spirit:displayName>addr</spirit:displayName>
     <spirit:bitOffset>11</spirit:bitOffset>
     <spirit:bitWidth>21</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_INTR_LINE</spirit:name>
    <spirit:displayName>Interrupt Line</spirit:displayName>
    <spirit:description>The Interrupt Line register is an eight-bit register used to communicate interrupt line routing information. The register is read/write and must be implemented by any device (or device function) that uses an interrupt pin. POST software will write the routing information into this register as it initializes and configures the system. The value in this register tells which input of the system interrupt controller(s) the device's interrupt pin is connected to. The device itself does not use this value, rather it is used by device drivers and operating systems. Device drivers and operating systems can use this information to determine priority and vector information. Values in this register are system architecture specific.</spirit:description>
    <spirit:addressOffset>0x3c</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:field>
     <spirit:name>unspecified</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-write</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_INTR_PIN</spirit:name>
    <spirit:displayName>Interrupt Pin</spirit:displayName>
    <spirit:description>The Interrupt Pin register tells which interrupt pin the device (or device function) uses. Devices (or device functions) that do not use an interrupt pin must put a 0 in this register. The values 05h through FFh are reserved. This register is read-only. Refer to Section 2.2.6 for further description of the usage of the INTx# pins.</spirit:description>
    <spirit:addressOffset>0x3d</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:field>
     <spirit:name>intx</spirit:name>
     <spirit:displayName>intx</spirit:displayName>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
     <spirit:enumeratedValues>
     <spirit:enumeratedValue>
      <spirit:name>NO_INT</spirit:name>
      <spirit:value>0x0</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>INTA</spirit:name>
      <spirit:value>0x1</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>INTB</spirit:name>
      <spirit:value>0x2</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>INTC</spirit:name>
      <spirit:value>0x3</spirit:value>
     </spirit:enumeratedValue>
     <spirit:enumeratedValue>
      <spirit:name>INTD</spirit:name>
      <spirit:value>0x4</spirit:value>
     </spirit:enumeratedValue>
     </spirit:enumeratedValues>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_MIN_GNT</spirit:name>
    <spirit:displayName>Min_Gnt</spirit:displayName>
    <spirit:description>MIN_GNT is used for specifying how long a burst period the device needs assuming a clock rate of 33 MHz. The value specifies a period of time in units of 1/4 microsecond. Values of 0 indicate that the device has no major requirements for the settings of Latency Timers. Devices should specify values that will allow them to most effectively use the PCI bus as well as their internal resources. Values should be chosen assuming that the target does not insert any wait-states. Implimentation Note: A fast Ethernet controller (100 Mbs) has a 64-byte buffer for each transfer direction. Optimal usage of these internal resources is achieved when the device treats each buffer as two 32-byte ping-pong buffers. Each 32-byte buffer has eight DWORDS of data to be transferred, resulting in eight data phases on the PCI bus. These eight data phases translate to . microsecond at 33 MHz, so the MIN_GNT value for this device is '1'. When moving data, the device will need to empty or fill a 32-byte buffer every 3.2 us (assuming a throughput of 10 MB/s). This would correspond to a MAX_LAT value of 12. </spirit:description>
    <spirit:addressOffset>0x3e</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:field>
     <spirit:name>value</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
   </spirit:register>
   <spirit:register>
    <spirit:name>PCIE_REG_MAX_LAT</spirit:name>
    <spirit:displayName>Max_Lat</spirit:displayName>
    <spirit:description>MAX_LAT is used for specifying how often the device needs to gain access to the PCI bus. The value specifies a period of time in units of 1/4 microsecond. Values of 0 indicate that the device has no major requirements for the settings of Latency Timers. Devices should specify values that will allow them to most effectively use the PCI bus as well as their internal resources. Values should be chosen assuming that the target does not insert any wait-states. Implimentation Note: A fast Ethernet controller (100 Mbs) has a 64-byte buffer for each transfer direction. Optimal usage of these internal resources is achieved when the device treats each buffer as two 32-byte ping-pong buffers. Each 32-byte buffer has eight DWORDS of data to be transferred, resulting in eight data phases on the PCI bus. These eight data phases translate to . microsecond at 33 MHz, so the MIN_GNT value for this device is '1'. When moving data, the device will need to empty or fill a 32-byte buffer every 3.2 us (assuming a throughput of 10 MB/s). This would correspond to a MAX_LAT value of 12. </spirit:description>
    <spirit:addressOffset>0x3f</spirit:addressOffset>
    <spirit:size>8</spirit:size>
    <spirit:volatile>true</spirit:volatile>
    <spirit:access>read-write</spirit:access>
    <spirit:field>
     <spirit:name>value</spirit:name>
     <spirit:bitOffset>0</spirit:bitOffset>
     <spirit:bitWidth>8</spirit:bitWidth>
     <spirit:access>read-only</spirit:access>
    </spirit:field>
   </spirit:register>
  </spirit:addressBlock>
 </spirit:memoryMap>
</spirit:memoryMaps>
